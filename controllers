Project Path: controllers Source Tree: ``` controllers ├── application_controller.rb ├── tasks_controller.rb ├── human_input_requests_controller.rb ├── agent_activities_controller.rb ├── projects_controller.rb ├── dashboard_controller.rb └── concerns ``` `/Users/estiens/code/ai/DoubleAgent/app/controllers/application_controller.rb`: ```rb class ApplicationController < ActionController::Base # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has. allow_browser versions: :modern end ``` `/Users/estiens/code/ai/DoubleAgent/app/controllers/tasks_controller.rb`: ```rb class TasksController < ApplicationController before_action :set_task, only: [:show, :edit, :update, :destroy, :activate, :pause, :resume, :complete, :fail] def index @tasks = Task.includes(:project).order(created_at: :desc) # Filter by project if project_id is provided if params[:project_id].present? @project = Project.find_by(id: params[:project_id]) @tasks = @tasks.where(project_id: params[:project_id]) if @project end end def show end def new @task = Task.new # Pre-select project if project_id is provided if params[:project_id].present? @task.project_id = params[:project_id] end end def edit end def create @task = Task.new(task_params) if @task.save redirect_to @task, notice: 'Task was successfully created.' else render :new end end def update if @task.update(task_params) redirect_to @task, notice: 'Task was successfully updated.' else render :edit end end def destroy @task.destroy redirect_to tasks_url, notice: 'Task was successfully destroyed.' end def activate if @task.may_activate? @task.activate! notice = 'Task was activated.' else notice = 'Task could not be activated.' end respond_to do |format| format.html { redirect_back(fallback_location: @task, notice: notice) } format.turbo_stream { flash.now[:notice] = notice @tasks = Task.where(state: ["active", "pending", "waiting_on_human", "paused"]).order(created_at: :desc).limit(10) render turbo_stream: [ turbo_stream.replace("tasks-container", partial: "dashboard/tasks", locals: { tasks: @tasks }), turbo_stream.replace("flash", partial: "layouts/flash") ] } end end def pause if @task.may_pause? @task.pause! notice = 'Task was paused.' else notice = 'Task could not be paused.' end respond_to do |format| format.html { redirect_back(fallback_location: @task, notice: notice) } format.turbo_stream { flash.now[:notice] = notice @tasks = Task.where(state: ["active", "pending", "waiting_on_human", "paused"]).order(created_at: :desc).limit(10) render turbo_stream: [ turbo_stream.replace("tasks-container", partial: "dashboard/tasks", locals: { tasks: @tasks }), turbo_stream.replace("flash", partial: "layouts/flash") ] } end end def resume if @task.may_resume? @task.resume! notice = 'Task was resumed.' else notice = 'Task could not be resumed.' end respond_to do |format| format.html { redirect_back(fallback_location: @task, notice: notice) } format.turbo_stream { flash.now[:notice] = notice @tasks = Task.where(state: ["active", "pending", "waiting_on_human", "paused"]).order(created_at: :desc).limit(10) render turbo_stream: [ turbo_stream.replace("tasks-container", partial: "dashboard/tasks", locals: { tasks: @tasks }), turbo_stream.replace("flash", partial: "layouts/flash") ] } end end def complete if @task.may_complete? @task.complete! notice = 'Task was marked as completed.' else notice = 'Task could not be completed.' end respond_to do |format| format.html { redirect_back(fallback_location: @task, notice: notice) } format.turbo_stream { flash.now[:notice] = notice @tasks = Task.where(state: ["active", "pending", "waiting_on_human", "paused"]).order(created_at: :desc).limit(10) render turbo_stream: [ turbo_stream.replace("tasks-container", partial: "dashboard/tasks", locals: { tasks: @tasks }), turbo_stream.replace("flash", partial: "layouts/flash") ] } end end def fail if @task.may_fail? @task.fail! notice = 'Task was marked as failed.' else notice = 'Task could not be marked as failed.' end respond_to do |format| format.html { redirect_back(fallback_location: @task, notice: notice) } format.turbo_stream { flash.now[:notice] = notice @tasks = Task.where(state: ["active", "pending", "waiting_on_human", "paused"]).order(created_at: :desc).limit(10) render turbo_stream: [ turbo_stream.replace("tasks-container", partial: "dashboard/tasks", locals: { tasks: @tasks }), turbo_stream.replace("flash", partial: "layouts/flash") ] } end end private def set_task @task = Task.find(params[:id]) end def task_params params.require(:task).permit(:title, :description, :state, :task_type, :priority, :project_id, :parent_id, metadata: {}) end end ``` `/Users/estiens/code/ai/DoubleAgent/app/controllers/human_input_requests_controller.rb`: ```rb class HumanInputRequestsController < ApplicationController before_action :set_human_input_request, only: [:show, :respond, :submit_response, :ignore] def show # Show details of a specific human input request end def respond # Show form to respond to the input request respond_to do |format| format.html format.turbo_stream end end def submit_response if @human_input_request.answer!(params[:response]) respond_to do |format| format.html { redirect_to dashboard_path, notice: "Response submitted successfully." } format.turbo_stream { flash.now[:notice] = "Response submitted successfully." } end else respond_to do |format| format.html { render :respond, status: :unprocessable_entity } format.turbo_stream { flash.now[:alert] = "Could not submit response." } end end end def ignore if @human_input_request.ignore!(params[:reason]) respond_to do |format| format.html { redirect_to dashboard_path, notice: "Input request ignored." } format.turbo_stream { flash.now[:notice] = "Input request ignored." } end else respond_to do |format| format.html { redirect_to dashboard_path, alert: "Could not ignore input request." } format.turbo_stream { flash.now[:alert] = "Could not ignore input request." } end end end private def set_human_input_request @human_input_request = HumanInputRequest.find(params[:id]) end end ``` `/Users/estiens/code/ai/DoubleAgent/app/controllers/agent_activities_controller.rb`: ```rb class AgentActivitiesController < ApplicationController before_action :set_agent_activity, only: [:show, :pause, :resume] def show # Load related data for the agent activity @llm_calls = @agent_activity.llm_calls.order(created_at: :desc) @events = @agent_activity.events.order(created_at: :desc) # Check for ancestry if @agent_activity.ancestry.present? @ancestors = @agent_activity.ancestors end # Get children @children = @agent_activity.children end def pause if @agent_activity.pause! respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, notice: "Agent paused successfully.") } format.turbo_stream { flash.now[:notice] = "Agent paused successfully." } end else respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, alert: "Could not pause agent.") } format.turbo_stream { flash.now[:alert] = "Could not pause agent." } end end end def resume if @agent_activity.resume! respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, notice: "Agent resumed successfully.") } format.turbo_stream { flash.now[:notice] = "Agent resumed successfully." } end else respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, alert: "Could not resume agent.") } format.turbo_stream { flash.now[:alert] = "Could not resume agent." } end end end private def set_agent_activity @agent_activity = AgentActivity.find(params[:id]) end end ``` `/Users/estiens/code/ai/DoubleAgent/app/controllers/projects_controller.rb`: ```rb class ProjectsController < ApplicationController before_action :set_project, only: [ :show, :edit, :update, :destroy, :kickoff, :pause, :resume ] # GET /projects def index @projects = Project.recent.all end # GET /projects/1 def show # Fetch all tasks for this project all_tasks = @project.tasks.includes(:parent) # Create a dependency graph for tasks @tasks_by_dependency = organize_tasks_by_dependency(all_tasks) # Keep the flat list for stats and other uses @tasks = all_tasks @stats = @project.task_status_counts @llm_stats = @project.llm_call_stats end # GET /projects/new def new @project = Project.new end # GET /projects/1/edit def edit end # POST /projects def create @project = Project.new(project_params) if @project.save redirect_to @project, notice: 'Project was successfully created. Click "Kickoff" to start the project.' else render :new end end # PATCH/PUT /projects/1 def update if @project.update(project_params) redirect_to @project, notice: "Project was successfully updated." else render :edit end end # DELETE /projects/1 def destroy @project.destroy redirect_to projects_url, notice: "Project was successfully destroyed." end # POST /projects/1/kickoff def kickoff if @project.status == "pending" orchestration_task = @project.kickoff! if orchestration_task redirect_to @project, notice: "Project has been kicked off! The system is now planning your project." else redirect_to @project, alert: "Failed to kickoff project. Is it already active or does it already have tasks?" end else redirect_to @project, alert: "Project can only be kicked off when in pending status." end end # POST /projects/1/pause def pause if @project.status == "active" if @project.pause! notice = "Project paused successfully." else notice = "Could not pause project." end respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, notice: notice) } format.turbo_stream { flash.now[:notice] = notice render turbo_stream: [ turbo_stream.replace("projects-container", partial: "dashboard/projects", locals: { projects: Project.order(created_at: :desc).limit(10) }), turbo_stream.replace("flash", partial: "layouts/flash") ] } end else respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, alert: "Could not pause project.") } format.turbo_stream { flash.now[:alert] = "Could not pause project." render turbo_stream: turbo_stream.replace("flash", partial: "layouts/flash") } end end end # POST /projects/1/resume def resume if @project.status == "paused" if @project.resume! notice = "Project resumed successfully." else notice = "Could not resume project." end respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, notice: notice) } format.turbo_stream { flash.now[:notice] = notice render turbo_stream: [ turbo_stream.replace("projects-container", partial: "dashboard/projects", locals: { projects: Project.order(created_at: :desc).limit(10) }), turbo_stream.replace("flash", partial: "layouts/flash") ] } end else respond_to do |format| format.html { redirect_back(fallback_location: dashboard_path, alert: "Could not resume project.") } format.turbo_stream { flash.now[:alert] = "Could not resume project." render turbo_stream: turbo_stream.replace("flash", partial: "layouts/flash") } end end end private # Organizes tasks by their dependencies # Returns a hash with: # - :independent => array of tasks with no dependencies # - :dependent => hash of dependent tasks grouped by their dependencies # - :dependency_map => hash mapping task_id to array of tasks that depend on it def organize_tasks_by_dependency(tasks) result = { independent: [], dependent: {}, dependency_map: {} } # First, identify independent vs dependent tasks tasks.each do |task| if task.depends_on_task_ids.empty? result[:independent] << task else # Group dependent tasks by their dependencies task.depends_on_task_ids.each do |dep_id| result[:dependent][dep_id] ||= [] result[:dependent][dep_id] << task # Build reverse mapping for easy lookup result[:dependency_map][task.id] ||= [] result[:dependency_map][task.id] << dep_id end end end # Sort independent tasks by created_at result[:independent].sort_by!(&:created_at) # Sort each dependency group by created_at result[:dependent].each do |dep_id, dependent_tasks| dependent_tasks.sort_by!(&:created_at) end result end def set_project @project = Project.find(params[:id]) end def project_params params.require(:project).permit(:name, :description, :priority, :due_date, :settings, :metadata) end end ``` `/Users/estiens/code/ai/DoubleAgent/app/controllers/dashboard_controller.rb`: ```rb class DashboardController < ApplicationController # Refresh dashboard data every 5 seconds def index @projects = Project.order(created_at: :desc).limit(10) @agent_activities = AgentActivity.order(created_at: :desc).limit(20) @events = Event.order(created_at: :desc).limit(30) @llm_calls = LlmCall.order(created_at: :desc).limit(15) @tasks = Task.where(state: [ "active", "pending", "waiting_on_human" ]).order(created_at: :desc).limit(10) # Handle HumanInputRequest with or without status column if HumanInputRequest.column_names.include?("status") @human_input_requests = HumanInputRequest.where(status: "pending").order(created_at: :desc).limit(5) else @human_input_requests = HumanInputRequest.order(created_at: :desc).limit(5) end # For Turbo Stream updates respond_to do |format| format.html format.turbo_stream end end end ```
